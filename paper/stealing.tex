The code for the stealing operation is detailed in Algorithm~\ref{}. We will describe the steal operation in which $c_1$ is stealing a chunk from $c_2$. The steal operation has two parts: (1) Stealing the chunk, and (2) Stealing the first task from the chunk.

\paragraph{Stealing the chunk.} Before stealing a chunk, $c_1$ has to make sure $c_2$ will not take any more tasks from that chunk, so the $c_1$ may later take tasks with no need for synchronization. To achieve this $c_1$ must change the owner field of the chunk. Changing the ownership will prevent $c_2$ from taking tasks as a consumer always checks that he is the owner of the chunk before taking tasks. 

Before changing the ownership we must relate to two issues: (1) Stealing a chunk from the pool of consumer $c_2$ is allowed only if $c_2$ is the owner of the chunk that we steal, this is needed so it is guaranteed that $c_2$ reads the latest value of the idx, which is only found in the owner's node. (2) We want that other consumers would be able to steal the chunk during the process, so that the algorithm will stay lock-free. 

For those two reasons we must make the chunk accessible via $c_1$'s pool before changing ownership. However, we cannot simply add a new node to $c_1$'s steal list, as that node's idx field will not be updated if $c_2$ changes his idx field. Therefore, before changing ownership, $c_1$ adds $c_2$'s node to his steal list (Line~\ref{} in Algorithm~\ref{}). Now $c_1$ takes ownership (Line~\ref{}) and creates a new node with the updated idx that will replace the $c_2$'s node (Line~\ref{}), as the original idx may only change by one pending operation at most. Finally $c_1$ changes $c_2$'s node to point to NULL (Line~\ref{}) so that this node will not be used and will be lazily removed.

\paragraph{Taking the first task.} After the $c_1$ stole the chunk, he must attempt to take a task, so Property~\ref{steal-progress-property} will hold. $c_1$ will try to take the task at $idx+1$, however, this task may be also taken by $c_2$ if he started a consume operation before $c_1$ completed the node transfer. This is why $c_1$ must use a CAS operation to take this node (Line~\ref{}). $c_2$ must also attempt to take this node (Line~\ref{}) even if he noticed the ownership change, since he does not know if $c_1$ read the idx value before or after $c_2$ increased it Line~\ref{}.

\vspace{5mm}\noindent
We claim that the steal operation hold Property~\ref{steal-progress-property}. In line~\ref{} a chunk with at least one task is taken, therefore there is a task at $idx+1$. if $idx$ is updated during the stealing operation it means that the original consumer is taking that task and therefore the property holds. Otherwise, either the CAS in line~\ref{} failed and another consumer successfully stole the chunk and will return a task, or the current producer will reach line~\ref{}. In this line the CAS will be executed if the task wasn't already taken, and since either the stealing consumer or the original consumer will succeed performing the CAS.