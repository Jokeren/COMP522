\negspace
In the current section we present our framework for scalable and NUMA-aware producer-consumer data exchange. 
Our system follows the principle of separating mechanism and policy.
We therefore consider two independent logical entities: 
\snegspace
\begin{enum*}
	\item \emph{A single consumer pool (SCPool)} mechanism manages the tasks arriving to a given consumer and allows stealing some tasks by other consumers.
	\item A management policy operates SCPools: the policy routes producers' requests to the appropriate consumers and initiates stealing between the pools. This way, the policy controls the system's behavior according to considerations of load-distribution, throughput, fairness, locality, etc.
	We are especially interested in a management policy suitable for Non-Uniform Memory Access (NUMA) architectures (see Figure~\ref{fig:system-fig}), where each CPU has its own memory, and accessing the memory of other CPUs is executed over an interconnect. As a high rate of remote memory accesses can decrease the performance, it is desirable for an SCPool of a consumer to reside at the RAM close to its own CPU. 
\end{enum*} 

\negspace
\paragraph{SCPool abstraction.}
\input{SCPoolAPI}
The SCPool API provides the abstraction of a single-consumer task pool with stealing support, see Algorithm~\ref{alg:scpool-api}.
A producer can invoke two types of insertion operations: {\bf produce()}, which attempts to insert a task to the given pool and fails if the pool is full, and {\bf produceForce()}, which always succeeds by expanding the pool on demand.
There are also two ways to retrieve a task from the pool: the owner of the pool (only) can call the {\bf consume()} function; while any other thread can invoke the {\bf steal()} function, which tries to transfer a number of tasks between the pools and return one of the stolen tasks. 
% The pool must guarantee the following \emph{stealing property}, which is necessary for system liveness:
% \begin{property}
% \label{steal-progress-property}
% If an SCPool is not empty at the beginning of a steal operation, then either the steal operation retrieves a task, or another thread started an operation $op$ during the steal execution, such that $op$ is guaranteed to retrieve a task.
% \end{property}

A straightforward way to implement the API described above is to use a dynamic-size multi-producer multi-consumer FIFO queue (e.g., Michael-Scott queue~\cite{Michael:1996:SFP:248052.248106}).
In this case, {\bf produce()} enqueue a new task, while both {\bf consume()} and {\bf steal()} dequeue a task. In the next section we present SALSA, a much more efficient SCPool.

%\begin{wrapfigure}{l}{0.5\textwidth}
%  \vspace{-20pt}
%  \begin{center}
%    \includegraphics[width=0.48\textwidth]{figures/system-fig}
%  \end{center}
%  \vspace{-20pt}
%  \caption{\footnotesize{Producer-consumer system overview. In the given example, the system is composed of two processors connected to two memory banks (NUMA architecture). There are two producers and two consumers running on each processor, and the data of each consumer is allocated at the closest available physical memory. A producer $p_i$ has an access list of consumers for task insertion. A consumer $c_i$ has an access list of consumers for task stealing.}}
%  \vspace{-10pt}
%  \label{fig:system-fig}
%\end{wrapfigure}

\begin{figure}[htb]
	\centering
	\includegraphics[width=0.6\textwidth]{figures/system-fig}
	\caption{\footnotesize{Producer-consumer system overview. In the given example, the system is composed of two processors connected to two memory banks (NUMA architecture). There are two producers and two consumers running on each processor, and the data of each consumer is allocated at the closest available physical memory. A producer $p_i$ has an access list of consumers for task insertion. A consumer $c_i$ has an access list of consumers for task stealing. }}
	\label{fig:system-fig}
\end{figure}

\negspace
\paragraph {Management policy.}
A management policy is generally defined by the way in which: 1) a producer chooses an SCPool for task insertion; and 2) a consumer decides when to retrieve a task from its own pool and steal tasks from other pools. 
Note that the policy is independent of the underlying SCPool implementation. We believe that the policy is a subject for engineering optimizations, based on specific workloads and demands.

In the current work, we present a policy that exploits the locality properties of NUMA architectures and is aimed at achieving maximal throughput. If the individual SCPools themselves are lock-free, then our policy preserves the lock-freedom at the system level. Our policy is as follows:
\snegspace
\begin{item*}
	\item {\bf Access lists.} Each process in the system (producer or consumer) is provided with an \emph{access list}, an ordered list of consumers, sorted according to their distance from that process (see Figure~\ref{fig:system-fig}). Intuitively, our intention is to have a producer mostly interact with the closest consumer, while stealing mainly happens inside the same processor node. 
	\item {\bf Producer's policy.} A producer inserting a task first calls the {\bf produce()} of the first SCPool in its access list. Note that this operation might fail if the pool is full, (which can be seen as evidence of that the corresponding consumer is overloaded).  In this case, the producer tries to insert the task into other pools, in the order defined by its access list. If all insertions fail, the producer invokes the {\bf produceForce()} operation on the closest SCPool, which always succeeds (expanding the pool if needed). 
	\item {\bf Consumer's policy.} A consumer takes tasks from its own SCPool. If its SCPool is empty, the consumer tries to steal tasks from other pools in the order defined by its access list. The issue of when (after how many stealing attemps) a consumer gives up and returns $\bot$ is subtle, and we discuss it in Section~\ref{sec:correctness}. Stealing can serve two purposes: first, it is important for distributing the load among all available consumers. Second, it ensures that tasks are not lost in case they are inserted into  the SCPool of a crashed (or  very slow) consumer.
\end{item*}
