\paragraph{Task pools\\}
There is a large body of work on lock-free unbounded FIFO queues and LIFO
stacks\cite{Gidenstam:2010:CLQ:1940234.1940266,Hendler:2004:SLS:1007912.1007944,
Hoffman:2007:BQ:1782394.1782423, Michael:1996:SFP:248052.248106,Moir:2005:UEI:1073970.1074013},
The problem with such algorithms is that due to the inherent need for ordering of operations they
scale poorly and provide low locality, and are therefore not useful as a consumer-producer task
pool. 

A number of previous works have recognized this limitation of FIFO, and observed that strict FIFO
order is seldom needed in multi-core systems
\cite{Afek:2010:SPP:1885276.1885295,springerlink:10.1007/978-3-642-17653-1_29,
Basin:2011:CST:2075029.2075087,Sundell:2011:LAC:1989493.1989550}. 

The closest such system to our implementation is to our work is the Concurrent Bag of Sundell et al.
\cite{Sundell:2011:LAC:1989493.1989550}, a non-FIFO producer-consumer pool, which, like SALSA, is
composed of per-producer chunk lists. Unlike our pool however, their consume operation requires a
strong atomic operation and steals are performed in the granularity of single tasks and not whole
chunks. Moreover, those pools are not scalable (i.e., the in system throughput does not increase as
more threads are added).

Other pools provide similar properties, and are not scalable as well. And also use different
techniques then we do in our work.

\paragraph{Techniques\\}
Some of the techniques used in our work were previously used in other works in different
variations. Work-stealing is a standard way to reduce contention by using separate per-consumer
pools \cite{Blumofe:1999:SMC:324133.324234} where task may be stolen from one pool to another.
In the common case where no steals are made, the algorithm may ran a \emph{fast-path} with
no synchronization. The concept of a synchronization-free fast-path appears in scheduling queues
\cite{Arora:1998:TSM:277651.277678}. However, these works assumes the same process is both the
producer and consumer, and hence synchronization-free operations were only used for a process to
transfer data to \emph{itself}. In our pool on the other hand, there is a distinction between
producers and consumers, and moreover, multiple producer may work on a single consumer pool even
without stealing. We do not know of any other work that achieves a synchronization-free fast-path
among multiple producers as we do. Furthermore, our steal algorithm steals a whole chunk of tasks
rather than just one task as most works do. \cite{Hendler:2002:NSW:571825.571876} is the only
exception we are familiar with which allows steals of multiple items, however it handles only
static-sized arrays and uses synchronization operations in the fast-path. 

Chunk-based data-structures
\cite{Braginsky:2011:LLL:1946143.1946153, 
Gidenstam:2010:CLQ:1940234.1940266,
Hendler:2006:DNW:1160290.1160294, Sundell:2011:LAC:1989493.1989550} use linked-list of chunks so
that the data structure will be of dynamic size while maintaining data-locality. We also use
chunk-based lists for that reason, furthermore, in SALSA steals are done in resolution of chunks.