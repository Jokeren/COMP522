Recall that we denote by $c$ the number of consumers.
As we show on Section~\ref{sec:correctness}, the proof that our system is lock-free, relies on the following claim:

\newtheorem*{claim:lock-free}{Claim \ref{claim:lock-free}}
\begin{claim:lock-free}
If a consumer returns $\bot$ in $c$ steal attempts from non-empty pools (i.e., pools that contain a task when the steal operation starts), then at least one consumer in the system returns a task during that time. 
\end{claim:lock-free}
\begin{proof}
We argue that the above claim is true in SALSA. Consider a consumer that invokes {\bf steal()} on a non-empty pool. This operation may fail to return a task in five cases:
\begin{enumerate}
 \item The {\bf if} statement in line~\ref{alg:line:steal-node-empty} is true. In this case all the tasks were already taken from this chunk. However, in line~\ref{alg:line:take-steal-chunk}, the steal operation took a chunk containing tasks, and therefore tasks were taken from this chunk (by other consumers) during the steal operation.
 \item The {\bf if} statement in line~\ref{alg:line:cas-steal} is true. This may occur because task$=$TAKEN or because the CAS fails. In both cases, it means that the task pointed to by $idx+1$ was taken by another consumer during the operation.
 \item The {\bf if} statement in line~\ref{alg:line:steal-chunk-not-full} is true. This means that the next available task pointed by $idx+1$ is a free slot in the chunk. However when the task was chosen in line~\ref{alg:line:take-steal-chunk}, the chunk contained a task, i.e., $idx+1$ pointed to a non-empty slot. This means that $idx$ was increased by the owner of the pool and so by the time its operation completes, it either returns the task or fails in the CAS because the task has already been returned.
 \item The {\bf if} statement in line~\ref{alg:line:check-steal-chunk-null} is true. In this case, no stealable chunks are found (i.e., chunks that contain a task and their owner is the owner of the current pool). Since we assume that the pool contains a task, this mean that either a concurrent {\bf consume()} operation returned a task, or a another {\bf steal()} operation successfully stole a chunk, and for that operation one of the first three cases apply, and therefore, there is another operation upon whose completion a task will be returned.
 \item The {\bf if} statement in line~\ref{alg:line:chown} is true, In this case, the steal operation fails because another consumer steals this chunk. Since the consumer that stole this chunk succeed in its CAS in line~\ref{alg:line:chown}, the current case can not apply for it, and therefore its operation either returns a task, or one of the first three  cases applies to it and therefore there is another operation that upon its completion a task will be returned. 
\end{enumerate}
In the first two cases there is another consumer that returns a task and the claim holds. In the last three cases there is another consumer that either returns a task or is running an operation that cannot end without a task being returned. If $c-1$ {\bf steal()} operations do not return a task, and during that time no other consumer returns a task, we know that all the consumers are running operations that cannot finish without a task being returned. Thus, either the $c$'th steal will not be interrupted and return a task, or one of the pending operations will return a task. The claim follows.
\end{proof}