As we show on Section~\ref{sec:correctness}, in order to show that our system is lock-free, it is enough to prove the following claim:

\newtheorem*{claim:lock-free}{Claim \ref{claim:lock-free}}
\begin{claim:lock-free}
If a consumer returns $\bot$ in $c$ steal attempts from non-empty pools (i.e., pools that contain a task when the steal operation starts), where $c$ is the number of consumers in the system, then at least one consumer in the system returns a task during that time. 
\end{claim:lock-free}
\begin{proof}
We argue that the above claim is true SALSA with the modifications describe above. Consider a consumer that invokes {\bf steal()} on a non-empty pool. This operation may fail to return a task in four cases:
\begin{enumerate}
 \item The {\bf if} statement in line~\ref{alg:line:steal-node-empty} is true. In this case all the tasks were already taken from this chunk. However, in line~\ref{alg:line:take-steal-chunk}, the steal operation took a chunk containing tasks, and therefore tasks were taken from this chunk (by other consumers) during the steal operation.
 \item The {\bf if} statement in line~\ref{alg:line:cas-steal} is true. This may occur because task$=$TAKEN or because the CAS fails. In both cases, it means that the task pointed to by $idx+1$ was taken by another consumer during the operation.
 \item The {\bf if} statement in line~\ref{alg:line:steal-chunk-not-full} is true. This means that the next available task pointed by $idx+1$ is a free slot in the chunk. However when the task was chosen in line~\ref{alg:line:take-steal-chunk}, the chunk contained a task, i.e., $idx+1$ pointed to a non-empty slot. This means that $idx$ was increased by the owner of the pool and so by the time its operation completes, it either returns the task or fails in the CAS because the task has already been returned.
 \item The {\bf if} statement in line~\ref{alg:line:chown} is true, In this case, the steal operation fails because another consumer steals this chunk. Since the consumer that stole this chunk succeed in his CAS in line~\ref{alg:line:chown}, the current case can not apply for it and therefore its operation either returns a task, or one of the above cases applies to it and therefore there is another operation that upon its completion a task will be returned. 
 \item The {\bf if} statement in line~\ref{alg:line:check-steal-chunk-null} is true, In this case, no stealable chunks are found (i.e., chunks that contain a task and its owner is the owner of the current pool). Since we assumed the the pool contains a task, this mean that either a concurrent consume operation returned a task or a another steal operation successfully stole a chunk and therefore one of the first three conditions apply, therefore there is another operation that upon its completion a task will be returned.
\end{enumerate}
In the first two cases there is another consumer that returns a task and the claim holds. In the last three cases there is another consumer which either returns a task or is running an operation which, cannot end without a task being returned. If $c-1$ steals operation do not return a task, and during that time no other consumer returns a task, we know that all the consumers are running operations that cannot finish without a task being returned, either the $c$'th steal will not be interrupted and return a task, or one of the pending operations will return a task. Therefore, when this operation ends it is guaranteed that a task will be taken from the pool and the claim holds.
\end{proof}