The algorithm as described in the previous sections, is trivially wait-free as all operations of the SALSA pool always return, and the policy only calls to a bounded number of those operations. However, this algorithm is not linearizable because operation may return $\bot$ even when the pool contains task. For example, consider the following scenario: consumer $c_a$ is failed to take a task from his own pool and started looking for chunks to steal in other pools. if there is a single chunk in the system in $c_b$'s pool, then $c_a$ might check $c_c$'s pool, see that it is empty, then a producer adds a task to $c_c$ pools and then $c_b$ takes the last task from his pool and only then $c_a$ checks $c_b$'s pool, and finds it empty and therefore returns $\bot$. This operation isn't linearizable, because during the execution of the operation the system contained a task.  

In this section we described a way to make our algorithm linearizable and argue that it is lock-free. The algorithm is not linearizable since a consumer may return $\bot$ even if the pool is not empty during his operation. This happens when a consumer traversing the pools when searching for chunks, might ``miss'' chunks in two cases: 1) in a scenario like the one described above where another consumer removes a chunk after taking the last task from it, and 2) in the case a chunk is moved from one pool to another due to stealing. In order to identify those cases each pool will have a special counter we call \emph{emptyCount} which will be increased every time a chunk is reclaimed or stolen (i.e. every time a chunk leaves the pool).

We change the policy so a new method called {\bf checkEmpty()} method, is call after a consumer fails to retrieve tasks from his pool and the other pools. {\bf checkEmpty()} ensures that there is a time when there are no tasks in the system before returning $\bot$. If the {\bf checkEmpty()} method finds that the pool is not empty, the consumer tries again to get a task. The {\bf checkEmpty()} works as follows: the consumer traverses all the chunk lists of all SALSA pools in the system, and reads the values of the \emph{emptyCount} of the SALSA pools. The consumer repeats this traversal for \#consumers +1 times, where in all the traversals after the first one it makes sure that the \emph{emptyCount} value is equal to the value it saw in the first traversal. This assures that the system has not changed and that no chunks were moved during the traversal. The reason the consumer has to make \#consumers+1 traversals is that there may be operations that moved chunks but did not yet change \emph{emptyCount}, since there may be up to \#consumers pending operations, in the last traversal it is guaranteed that during one of the traversals the system contained no tasks and therefore it is safe to return $\bot$. This method is similar to the one used in the Concurrent Bags~\cite{Sundell:2011:LAC:1989493.1989550} work, however, while our method requires a single fetch-and-increment operation only once per-steal or per-chunk, their operation required an additional write on every produce operation and a CAS operation for every empty chunk encountered in the traversal.
The policy as described above, does not require that the consumer will finish his operation. For example, if the consumer's pool is empty, and the steal operation always fails, while the system always contains chunks. If we want the system to be lock-free, we must make sure that even if a consumer blocks, there is some other consumer that made progress. In order to show that our system is lock-free we claim the following: 

\begin{claim}
If a consumer failed at $c$ steal attempts from non-empty pools, where $c$ is the number of consumers in the system, then it is guaranteed that at least one consumer in the system returned a task during that time. 
\end{claim}

We argue that the above claim is true when using SALSA with the modifications describe above. Consider a consumer that invokes {\bf steal()} on a non-empty pool, this operation may not return a task in four cases:
\begin{enumerate}
 \item The {\bf if} statement in line~\ref{alg:line:steal-node-empty} was true, in this case all the tasks were already taken from this chunk, however, in line~\ref{alg:line:take-steal-chunk} the steal operation took a chunk containing tasks and therefore tasks were taken from this chunk during this steal operation.
 \item The {\bf if} sthe tatement in line~\ref{alg:line:cas-steal} is true, in this case it may fail because task$=$TAKEN or if the CAS fails, in both cases it means the task pointed to by idx+1 was taken by another consumer.
 \item The {\bf if} statement in line~\ref{alg:line:steal-chunk-not-full} is true, This means that the local node idx+1 pointer to a free slot in the chunk, however when the task was chosen in line~\ref{alg:line:take-steal-chunk} the chunk contained a task i.e., idx+1 pointer to a non-empty slot. This means idx was increased by the owner of the pool and his operation will eventually return a task.
 \item The {\bf if} statement in line~\ref{alg:line:chown} is true, then the steal operation failed because another consumer stole this  chunk. In this case another consumer successfully stole this chunk and his operation either returns a task or one of the above cases will apply for him. 
\end{enumerate}

\underline{\bf DRAFT:::}

In the first two cases there is another consumer that returned a task and the claim holds. In the last two cases there is another consumer which either returns a task or is running an operation that will eventually return a task. after $c-1$ steals operation that did not return a task and no other consumers returned a task, it means that those consumers are in a middle of an operation and therefore this operation will not be interrupted or one of the pending operations will return a task, therefore there is an operation that will return a task when the steal operation ends.  

If the above claim is true, then even if a consumer does not make any progress then it is guaranteed that after $c$ steal attempts another consumer made progress and therefore the system is lock-free.